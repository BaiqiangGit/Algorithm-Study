This is my understanding on the code posed in:

Solution to Triangle by codility
https://codesays.com/2014/solution-to-triangle-by-codility/

Corresponding to codility question:
https://app.codility.com/c/run/trainingAGWCC7-E4D

The question is asking whether at least trangle exists given the edges described by 3 of the list elements.
Have a look at Sheng's solution first:

def solution(A):
    A_len = len(A)
    if A_len < 3:
        # N is an integer within the range [0..1,000,000]
        # if the list is too short, it is impossible to
        # find out a triangular.
        return 0
 
    A.sort()
 
    for index in xrange(0, A_len-2):
        if A[index]+A[index+1] > A[index+2]:
            return 1
        # The list is sorted, so A[index+i] >= A[index+2]
        # where i>2. If A[index]+A[index+1] <= A[index+2],
        # then A[index]+A[index+1] <= A[index+i], where
        # i>=2. So there is no element in A[index+2:] that
        # could be combined with A[index] and A[index+1]
        # to be a triangular.
 
    # No triangular is found
    return 0
    
    It first sorts the list, then check only the consecutive triplet values.  What's the logic behind this?
    
    Questions:
    (1) how does checking consecutive triplet in sorted(A), equal checking all possible triplets in A? given this exist or not question? Any possible missing coverage of the problem in this 'equilevant' tranformation?
    (2) how dose sorted(A) offer an easier way for analyze in this problem?
    
    First, taking 3 random elements (no need to be consecutive) from A and check if they fit the triangle criteria, equals to check these 3 elements in sorted(A). The 3 elements have an order themselves, and we didn't add any extra info. Picking 3 elements from list A, is equilevant to picking 3 elements in sorted(A). 
    Second, in sorted(A), suppose the triplet (a b c) positions looks like this: ... a-1, a, a + 1,....b-1, b, b + 1,....c-2, c-1, c, c+c2,.. . We are checking if A[a] + A[b] > A[c], A[a] + A[c] > A[b], A[b] + A[c] > A[a]. Immediately, as A[i] > 0 and the list is ascending, requirements for A[a] + A[c] > A[b], A[b] + A[c] > A[a] already meet. The only remaining one is A[a] + A[b] > A[c] which leads to whether or not the triplet makes a triangle.
    Third, as this is exist or not problem, the aim is to find when there is no triangle triplet. Look at this again:... a-1, a, a + 1,....b-1, b, b + 1,....c-2, c-1, c, c+c2,.. .  A[a]<=A[c-2], A[b] <= A[c-1]. If A[c-2] + A[c-1] < A[c], then A[a] + A[b] < A[c] is for sure. It means that we need only to check if A[c-2] + A[c-1] < A[c], to determine if at least one triangle triplet exist with edges no larger than c.
    Iterate this to the end and if no fit triangle for each possible max edge length, return 0, otherwise break the loop and return 1.
    
    You are what you write, and what you code. How much you could express that in words and codes, it's how much they have truely built up in yourself.
    
    
